# Exercise 04 - K-means Clustering


|                         |                    |
| -----------------------:| ------------------ |
|   Turn-in directory :   |  ex04              |
|   Files to turn in :    |  Kmeans.py         |
|   Forbidden functions : |  None              |
|   Remarks :             |  n/a               |


ALERT! DATA CORRUPTED

**Objective:**

The solar system census dataset is corrupted! The citizens' homelands are missing!  
You must implement the K-means clustering algorithm in order to find the citizens' origins.

On this web-page you can find good explainations on how K-means is working:  
https://bigdata-madesimple.com/possibly-the-simplest-way-to-explain-k-means-algorithm/  

The missing part is how to compute the distance between 2 data points (cluster centroid or a row in the data).  
In our case the data we have to process is composed of 3 values (height, weight and bone_density). We can say that each data point is of vector of 3 values.  
Now that we have mathematically defined our data points (Vector of 3 values), it is very easy to compute the distance between two points using vector properties. You could use L1 distance, L2 distance, cosine similarity, etc... Choosing this distance is called hyperparameter tunning, I would suggest you to try first with the easiest setting (L1 distance).  
Something you also have to notice is that the final result of the "training"/"fitting" will depend a lot on the random initialization. Communly in machine-learning libraries, K-mean is runned multiple times (with different random initialisations) and the best result is saved.  

NB: a centroid can be coincidered as the gravity center of a set of points. To implement the fit function you have to keep this in mind.  

**Instructions:**

Create the class KmeansClustering with the following functions:  

```python
class KmeansClustering:
    def __init__(self, max_iter=20, ncentroid=5):
        self.ncentroid = ncentroid # number of centroids
        self.max_iter = max_iter # number of max iterations to update the centroids
        self.centroids = [] # values of the centroids
        
    def fit(self, X):
        """
        Run the K-means clustering algorithm.
        For the location of the initial centroids, random pick ncentroids from the dataset.
        Args:
          X: has to be an numpy.ndarray, a matrice of dimension m * n.
        Returns:
          None.
        Raises:
          This function should not raise any Exception.
        """

    def predict(self, X):
        """
        Predict from wich cluster each datapoint belongs to.
        Args:
          X: has to be an numpy.ndarray, a matrice of dimension m * n.
        Returns:
          the prediction has a numpy.ndarray, a vector of dimension m * 1.
        Raises:
          This function should not raise any Exception.
        """
```
**Dataset:**

The dataset, named **solar_system_census** can be found in the resources folder.  
It is a part of the solar system census dataset, and contains biometric informations such as the height, weight, and bone density of solar system citizens.  

As you should know solar citizens come from four registered areas: The flying cities of Venus, United Nations of Earth, Mars Republic, and the Asteroids' Belt colonies.  

Unfortunately the data about the planets of origin was lost...  
Use your K-means algorithm to recover it!  
Once your clusters are found, try to find matches between clusters and the citizens' homelands.  

***Hints:***

* People are slender on Venus than on Earth.  
* People of the Martian Republic are taller than on Earth.  
* Citizens of the Belt are the tallest of the solar system and have the lowest bone density due to the lack of gravity.  


**Example:**

Here is an exemple of the algorithm in action:  
https://i.ibb.co/bKFVVx2/ezgif-com-gif-maker.gif
